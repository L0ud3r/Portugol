
 code -> s | code ';' s


 e -> VAR | '(' e ')' | b | n | string | VAR '(' e_list ')' | VAR '(' ')'

 b -> f | e OR e | e AND e | e XOR e

 f -> TRUE | FALSE | NOT f

 n -> NR | '-' e | e '+' e | e '-' e | e '*' e | e '/' e

 e_list -> e | e_list ',' e


 s -> func | comando                                          # check
 ciclo -> FOR var '[' e ELLIPSIS e ']' com_list ';' ENDFOR    # check
 condicao_se -> SE e com_list ';' FIMSE
 condicao_senao -> SENAO com_list ';' FIMSE | SENAO condicao_se ';' FIMSE     #not sure
 comando -> e | ciclo | VAR assign e | SAY e_list | READ var | condicao_se | condicao_senao      #isto permite que possa ler um senao mesmo fora de um se! fazer o eval disso e dar raise exception!
 com_list -> comando | com_list ';' comando                   # check
 func -> FUN var '(' args ')' com_list ';' ENDFUN             # check
 args -> € | var_list                                         # check
 var_list -> var | var_list ',' var                           # check


 Passagens para Portugol:

FOR            #DONE!
ANTIGO: FOR var [ e ELLIPSIS e ] com_list ; ENDFOR
NOVO: PARA var DE e ATE e FACA com_list ; FIMPARA

DECLARAÇÃO DE VARIAVEIS! (ainda nao existe)

SAY             #DONE!
ANTIGO: SAY e_list
NOVO: ESCREVA(e_list)

READ            #DONE!
ANTIGO: READ var
NOVO: LEIA(var)

FUN
ANTIGO: FUN var '(' args ')' com_list ';' ENDFUN
NOVO: ???






